// This script runs as a 'prebuild' hook to fetch live, sequential module data
// from the PostgreSQL database (Aiven) and write it to a static JavaScript
// file for the frontend, bypassing dynamic API calls during deployment.

// Using CommonJS require syntax for maximum compatibility with 'node' executor.
const { Client } = require('pg');
const fs = require('fs');
const path = require('path');

// --- Configuration ---

// The path where the final static data file will be written.
const OUTPUT_FILE_PATH = path.join(__dirname, '..','data', 'scenarios-content.ts');
// The DB connection string is expected to be set in the environment
const DATABASE_URL = process.env.DATABASE_URL;

/**
 * @typedef {Object} ScenarioItem
 * @property {number} id - The unique module ID.
 * @property {string} title - The title of the module (from the 'name' column).
 * @property {string} content_body - The JSON content string. NOTE: Must be JSON.parsed() in the client app.
 */

// --- Main Execution Function ---

async function generateScenarioContent() {
    if (!DATABASE_URL) {
        console.error('‚ùå Error: DATABASE_URL environment variable is not set.');
        console.error('   Please run: $env:DATABASE_URL="<your-uri>" before executing the script.');
        process.exit(1);
    }

    // AGGRESSIVE SSL BYPASS: Configure the client to always require SSL (per Aiven's mandate)
    // but unconditionally reject strict authorization to bypass the "self-signed certificate" error.
    const clientConfig = {
        connectionString: DATABASE_URL,
        ssl: {
            // Set rejectUnauthorized to false to allow self-signed certificates (Aiven's default).
            rejectUnauthorized: false
        }
    };

    // NOTE: The pg client will now look for the `ssl` object for configuration,
    // which prevents the URI parameter from conflicting with our code here.
    const client = new Client(clientConfig);

    console.log('üîó Connecting to Aiven database...');

    try {
        await client.connect();

        // SQL Query: Selects ID, NAME (aliased as title), and CONTENT_BODY
        // Orders by ID ascending to ensure sequential module delivery.
        const result = await client.query(`
            SELECT
                module_id,
                title,
                content_body
            FROM
                modules
            ORDER BY
                module_id ASC;
        `);

        /** @type {ScenarioItem[]} */
        const data = result.rows;

        // --- File Content Generation ---
        const fileContent = `
/**
 * WARNING: This file is AUTO-GENERATED by the pre-build script (scripts/pre-load-scenarios.js).
 * DO NOT EDIT MANUALLY.
 *
 * This content is read directly from the 'modules' table in the Aiven database
 * during the build process to provide static, type-safe scenario content.
 */

/**
 * @typedef {Object} ScenarioItem
 * @property {number} module_id - The unique module ID.
 * @property {string} title - The title of the module.
 * @property {string} content_body - The JSON content string (must be parsed).
 */

/** @type {ScenarioItem[]} */
const SCENARIOS_CONTENT = ${JSON.stringify(data, null, 2)};

export {
  SCENARIOS_CONTENT
};
`;

        fs.writeFileSync(OUTPUT_FILE_PATH, fileContent.trim());
        console.log(`\n‚úÖ Success! ${data.length} scenarios loaded.`);
        console.log(`   Data saved to: ${OUTPUT_FILE_PATH}`);

    } catch (err) {
        console.error('\n‚ùå Fatal Database Error during pre-build:');
        console.error(err.message || err);
        process.exit(1);

    } finally {
        await client.end();
    }
}

generateScenarioContent();
